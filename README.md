# Binance-Multi-Currency-Spot-Rebalancing-Strategy
策略介绍 - 平衡策略 (Rebalancing Strategy)
平衡策略是一种被动投资（Passive Investing）策略，它不尝试预测市场短期内的涨跌。它的核心思想是：
设定目标分配比例： 选择一篮子资产（在这里是多种加密货币），并为它们设定一个理想的价值分配比例。这段代码默认使用等权重分配，即所有目标币种的价值占总投资组合的比例相等（例如，5个币种，每个占 20%）。
定期或阈值触发检查： 程序会按照设定的时间间隔（例如每小时）或当某个币种的价值比例偏离目标超过设定的阈值时，检查当前的投资组合分配情况。
执行再平衡操作：
计算当前投资组合的总价值。
计算每个币种当前的价值以及占总价值的百分比。
计算每个币种与目标价值（总价值 / 币种数量）的差额。
对于价值低于目标的币种（当前比例偏低），计算需要买入多少才能达到目标价值。
对于价值高于目标的币种（当前比例偏高），计算需要卖出多少才能达到目标价值。
执行相应的买入和卖出交易，将实际持仓的价值比例拉回接近目标水平。
为什么使用平衡策略？
风险管理： 避免因某个币种价格暴涨导致其在投资组合中占比过高，一旦该币种下跌，整个投资组合会遭受较大损失。通过卖出高比例的币种，锁定部分利润。
纪律性： 强制执行“高卖低买”的行为（尽管不是主动判断高低点），因为你需要卖出那些涨得多的币种（自然价值比例就高了）去买入那些跌得多的币种（自然价值比例就低了）。
自动化： 一旦设置好，策略可以自动运行，省去了手动盯盘和交易的麻烦。
与市场无关： 策略的有效性不依赖于预测市场方向，而在于资产类别的相对表现。

这段 Python 代码将上述平衡策略封装在一个 CCXTBalancer 类中，并利用 asyncio 实现异步操作，以提高效率（尤其是在等待网络响应时）。
配置部分 (--- Configuration ---):
定义了所有策略的关键参数，如 API Key/Secret、目标币种列表、再平衡和报告的时间间隔、触发再平衡的阈值、基础货币等。
设置 Decimal 精度，确保金融计算的准确性。
safe_round_down_amount(amount_decimal, market) 函数:
功能： 这是一个非常重要的辅助函数，用于处理交易所的交易规则。交易所对每种币的交易数量（amount）和交易金额（cost/notional）都有最小限制和精度要求。这个函数根据交易所的市场信息（CCXT 的 market 数据），安全地向下取整你计算出的目标交易数量，确保它符合交易所的要求并且不会因为精度问题导致下单失败或多卖。如果计算出的数量小于交易所允许的最小数量，则返回 0。
CCXTBalancer 类:
__init__(...):
功能： 初始化类实例。在这里创建了与币安交易所的异步连接 (ccxt.binance(...))，配置 API Key/Secret，启用速率限制，并设置交易类型为现货 ('spot')。它还存储了所有的配置参数，并计算了每个目标币种的理论目标分配比例。
load_market_info(self):
功能： 从交易所加载最新的市场信息（交易对、精度、最小交易量/金额等规则）。这是运行策略前必需的步骤，确保后续的交易计算符合交易所的规定。它还会过滤出用户指定的目标币种中哪些是有效且活跃的交易对。
fetch_portfolio_data(self):
功能： 异步地从交易所获取两个关键信息：你的账户余额 (fetch_balance) 和目标交易对的最新价格 (fetch_tickers)。这些数据是计算当前投资组合价值和分配比例的基础。
calculate_allocations(self, balance, tickers):
功能： 接收余额和行情数据，计算当前的投资组合状态。它计算总资产的 USDT 价值，每个目标币种的当前 USDT 价值，以及每个币种占总价值的百分比。还会计算出在等权重分配下，每个币种理想中的 USDT 价值应该是多少。
report_current_allocations(self):
功能： 获取最新的投资组合数据，计算分配比例，并友好地打印出来，显示总价值、每个币种的当前百分比和目标百分比，以及是否因为偏差超过阈值而需要再平衡。
rebalance(self):
功能： 这是执行再平衡的核心方法。它首先获取最新数据，计算出哪些币种需要买入，哪些需要卖出，以及需要交易的数量（考虑到交易所的精度和最小交易限制）。然后，它创建并执行市价（'market'）订单来调整持仓。为了尽量确保有足够的 USDT 进行买入，它会优先执行卖单。交易完成后会立即进行一次报告。
perform_initial_allocation(self):
功能： 程序启动时（第一次运行时）调用。它会检查你账户中有多少可用的 USDT，并尝试使用你指定的 INITIAL_USDT_AMOUNT（或实际可用 USDT 中的较小值）来购买目标币种，以便在策略开始运行时，投资组合就初步接近目标分配。
run(self):
功能： 策略的主执行循环。它负责整个程序的流程控制：先加载市场信息，然后执行初始分配（如果需要），接着进入一个循环。在循环中，它会根据设定的时间间隔检查是否需要执行报告或再平衡操作。它会计算下一次需要执行任务的时间，然后使用 asyncio.wait_for(self.stop_event.wait(), timeout=...) 进行睡眠，直到时间到达或者接收到停止信号。
stop(self):
功能： 优雅停止机制的一部分。当程序接收到中断信号（如用户按 Ctrl+C）时，这个方法会被调用，它设置 self.stop_event 事件，通知主循环退出。
close(self):
功能： 优雅停止机制的一部分。在主循环退出后，这个方法会被调用，负责关闭与交易所的连接，释放资源。
主执行块 (async def main(): 和 if __name__ == "__main__":):
功能： 这是程序的入口点。它创建 CCXTBalancer 实例，配置信号处理程序（捕获 Ctrl+C 等信号以实现优雅停止），然后使用 asyncio.run(main()) 启动异步事件循环并运行策略的主逻辑。
